<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect-it!</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --animation-duration: 250ms;
            --preview-transition: 200ms;
            --cell-size: 70px;
            --grid-gap: 10px;
            --preview-circle-size: 60px;
            --cell-font-size: 28px;
            --header-font-size: 48px;
            --preview-font-size: 18px;
            --background-color: #faf8ef;
            --board-background: #bbada0;
            --text-color: #776e65;
            --button-background: #8f7a66;
            --empty-cell-color: #cdc1b4;
            --connection-line-thickness: 14px;
            --border-radius: 6px;
            --hover-scale: 1.05;
            --mobile-cell-size: 60px;
            --mobile-grid-gap: 5px;
            --mobile-preview-circle-size: 50px;
            --mobile-cell-font-size: 24px;
            --mobile-header-font-size: 36px;
            --mobile-preview-font-size: 16px;
            --mobile-connection-line-thickness: 12px;
        }

        body {
            font-family: Arial, sans-serif;
            background: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            text-align: center;
            max-width: 500px;
            width: 100%;
        }

        h1 {
            font-size: var(--header-font-size);
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .preview {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
        }

        .preview-circle {
            width: var(--preview-circle-size);
            height: var(--preview-circle-size);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: var(--preview-font-size);
            opacity: 0;
            transition: opacity var(--preview-transition);
        }

        .preview-circle.visible {
            opacity: 1;
        }

        /* Preview circle colors - same as cell colors */
        .preview-circle[data-value="2"] { background: #eee4da; color: #776e65; }
        .preview-circle[data-value="4"] { background: #ede0c8; color: #776e65; }
        .preview-circle[data-value="8"] { background: #f2b179; color: white; }
        .preview-circle[data-value="16"] { background: #f59563; color: white; }
        .preview-circle[data-value="32"] { background: #f67c5f; color: white; }
        .preview-circle[data-value="64"] { background: #f65e3b; color: white; }
        .preview-circle[data-value="128"] { background: #edcf72; color: white; }
        .preview-circle[data-value="256"] { background: #edcc61; color: white; }
        .preview-circle[data-value="512"] { background: #edc850; color: white; }
        .preview-circle[data-value="1024"] { background: #edc53f; color: white; }
        .preview-circle[data-value="2048"] { background: #edc22e; color: white; }

        /* Higher values cycle through colors */
        .preview-circle[data-value="4096"] { background: #eee4da; color: #776e65; }
        .preview-circle[data-value="8192"] { background: #ede0c8; color: #776e65; }
        .preview-circle[data-value="16384"] { background: #f2b179; color: white; }
        .preview-circle[data-value="32768"] { background: #f59563; color: white; }
        .preview-circle[data-value="65536"] { background: #f67c5f; color: white; }
        .preview-circle[data-value="131072"] { background: #f65e3b; color: white; }
        .preview-circle[data-value="262144"] { background: #edcf72; color: white; }
        .preview-circle[data-value="524288"] { background: #edcc61; color: white; }
        .preview-circle[data-value="1048576"] { background: #edc850; color: white; }
        .preview-circle[data-value="2097152"] { background: #edc53f; color: white; }
        .preview-circle[data-value="4194304"] { background: #edc22e; color: white; }

        .preview-circle.rim {
            border: 3px solid white;
            box-sizing: border-box;
        }

        .game-board {
            background: var(--board-background);
            border-radius: var(--border-radius);
            padding: var(--grid-gap);
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: var(--grid-gap);
            position: relative;
            margin-bottom: 20px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: var(--empty-cell-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: var(--cell-font-size);
            color: white;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
            position: relative;
            z-index: 10;
        }

        .cell:hover {
            transform: scale(var(--hover-scale));
        }

        .cell.rim {
            border: 3px solid white;
            box-sizing: border-box;
        }

        /* 2048-style colors */
        .cell[data-value="2"] { background: #eee4da; color: #776e65; }
        .cell[data-value="4"] { background: #ede0c8; color: #776e65; }
        .cell[data-value="8"] { background: #f2b179; color: white; }
        .cell[data-value="16"] { background: #f59563; color: white; }
        .cell[data-value="32"] { background: #f67c5f; color: white; }
        .cell[data-value="64"] { background: #f65e3b; color: white; }
        .cell[data-value="128"] { background: #edcf72; color: white; }
        .cell[data-value="256"] { background: #edcc61; color: white; }
        .cell[data-value="512"] { background: #edc850; color: white; }
        .cell[data-value="1024"] { background: #edc53f; color: white; }
        .cell[data-value="2048"] { background: #edc22e; color: white; }

        /* Higher values cycle through colors */
        .cell[data-value="4096"] { background: #eee4da; color: #776e65; }
        .cell[data-value="8192"] { background: #ede0c8; color: #776e65; }
        .cell[data-value="16384"] { background: #f2b179; color: white; }
        .cell[data-value="32768"] { background: #f59563; color: white; }
        .cell[data-value="65536"] { background: #f67c5f; color: white; }
        .cell[data-value="131072"] { background: #f65e3b; color: white; }
        .cell[data-value="262144"] { background: #edcf72; color: white; }
        .cell[data-value="524288"] { background: #edcc61; color: white; }
        .cell[data-value="1048576"] { background: #edc850; color: white; }
        .cell[data-value="2097152"] { background: #edc53f; color: white; }
        .cell[data-value="4194304"] { background: #edc22e; color: white; }

        .cell.connected {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            font-size: calc(var(--cell-size) * 0.75);
        }

        .connection-line {
            position: absolute;
            height: var(--connection-line-thickness);
            background: currentColor;
            transform-origin: left center;
            pointer-events: none;
            z-index: 5;
        }

        .cell.moving {
            transition: transform var(--animation-duration) ease-out;
            z-index: 20;
        }

        .cell.falling {
            transition: transform var(--animation-duration) ease-out;
            z-index: 15;
        }

        .cell.new-cell {
            animation: growIn var(--animation-duration) ease-out;
        }

        @keyframes growIn {
            0% {
                transform: scale(0);
            }
            100% {
                transform: scale(1);
            }
        }

        .button-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .reset-button, .settings-button {
            background: var(--button-background);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: var(--border-radius);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .reset-button:hover, .settings-button:hover {
            background: #9f8a76;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #faf8ef;
            margin: 2% auto;
            padding: 0;
            border-radius: 6px;
            width: 90%;
            max-width: 600px;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 1px solid #ddd;
        }

        .modal-header h2 {
            margin: 0;
            color: #776e65;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close:hover, .close:focus {
            color: #776e65;
        }

        .modal-body {
            padding: 30px;
        }

        .settings-section {
            margin-bottom: 30px;
        }

        .settings-section h3 {
            color: #776e65;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .settings-section label {
            display: block;
            margin-bottom: 10px;
            color: #776e65;
            font-weight: bold;
        }

        .settings-section input {
            margin-left: 10px;
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
            width: 80px;
        }

        .settings-section input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .modal-footer {
            padding: 20px 30px;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-button {
            background: #bbada0;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .modal-button:hover {
            background: #a59993;
        }

        .modal-button.primary {
            background: #8f7a66;
        }

        .modal-button.primary:hover {
            background: #9f8a76;
        }

        #jsonDisplay {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
            background: #f9f9f9;
        }

        @media (max-width: 600px) {
            .game-board {
                padding: var(--mobile-grid-gap);
                grid-gap: var(--mobile-grid-gap);
            }

            .cell {
                width: var(--mobile-cell-size);
                height: var(--mobile-cell-size);
                font-size: var(--mobile-cell-font-size);
            }

            .cell.connected {
                font-size: calc(var(--mobile-cell-size) * 0.75);
            }

            .connection-line {
                height: var(--mobile-connection-line-thickness);
            }

            h1 {
                font-size: var(--mobile-header-font-size);
            }

            .preview-circle {
                width: var(--mobile-preview-circle-size);
                height: var(--mobile-preview-circle-size);
                font-size: var(--mobile-preview-font-size);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Connect-it!</h1>
        <div class="preview">
            <div class="preview-circle" id="previewCircle"></div>
        </div>
        <div class="game-board" id="gameBoard"></div>
        <div class="button-row">
            <button class="reset-button" onclick="resetGame()">Reset</button>
            <button class="settings-button" onclick="openSettings()">Settings</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings</h2>
                <span class="close" onclick="closeSettings()">&times;</span>
            </div>
            <div class="modal-body">
                <form id="settingsForm">
                    <div class="settings-section">
                        <h3>Animations</h3>
                        <label>Animation Duration (ms): <input type="number" name="animationDuration" min="100" max="2000" step="50"></label>
                        <label>Preview Transition (ms): <input type="number" name="previewTransition" min="50" max="1000" step="50"></label>
                    </div>

                    <div class="settings-section">
                        <h3>Element Sizes</h3>
                        <label>Cell Size (px): <input type="number" name="cellSize" min="40" max="120" step="5"></label>
                        <label>Grid Gap (px): <input type="number" name="gridGap" min="2" max="20" step="1"></label>
                        <label>Preview Circle Size (px): <input type="number" name="previewCircleSize" min="30" max="100" step="5"></label>
                    </div>

                    <div class="settings-section">
                        <h3>Font Sizes</h3>
                        <label>Cell Font Size (px): <input type="number" name="cellFontSize" min="12" max="48" step="2"></label>
                        <label>Header Font Size (px): <input type="number" name="headerFontSize" min="24" max="72" step="4"></label>
                        <label>Preview Font Size (px): <input type="number" name="previewFontSize" min="10" max="32" step="2"></label>
                    </div>

                    <div class="settings-section">
                        <h3>Colors</h3>
                        <label>Background Color: <input type="color" name="backgroundColor"></label>
                        <label>Board Background: <input type="color" name="boardBackground"></label>
                        <label>Text Color: <input type="color" name="textColor"></label>
                        <label>Button Background: <input type="color" name="buttonBackground"></label>
                        <label>Empty Cell Color: <input type="color" name="emptyCellColor"></label>
                    </div>

                    <div class="settings-section">
                        <h3>Other</h3>
                        <label>Connection Line Thickness: <input type="number" name="connectionLineThickness" min="2" max="20" step="1"></label>
                        <label>Border Radius (px): <input type="number" name="borderRadius" min="0" max="20" step="1"></label>
                        <label>Hover Scale: <input type="number" name="hoverScale" min="1.0" max="1.3" step="0.05"></label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="modal-button" onclick="resetToDefaults()">Reset to Defaults</button>
                <button class="modal-button" onclick="copyAsJSON()">Copy as JSON</button>
                <button class="modal-button primary" onclick="applySettings()">Apply</button>
            </div>
        </div>
    </div>

    <!-- JSON Display Modal -->
    <div id="jsonModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Settings JSON</h2>
                <span class="close" onclick="closeJSON()">&times;</span>
            </div>
            <div class="modal-body">
                <textarea id="jsonDisplay" readonly></textarea>
            </div>
            <div class="modal-footer">
                <button class="modal-button" onclick="copyJSONToClipboard()">Copy to Clipboard</button>
                <button class="modal-button primary" onclick="closeJSON()">Close</button>
            </div>
        </div>
    </div>

    <script>
        class SettingsManager {
            constructor() {
                this.defaults = {
                    // Animation settings
                    animationDuration: 250,
                    previewTransition: 200,

                    // Element sizes
                    cellSize: 70,
                    gridGap: 10,
                    previewCircleSize: 60,

                    // Font sizes
                    cellFontSize: 28,
                    headerFontSize: 48,
                    previewFontSize: 18,

                    // Colors
                    backgroundColor: '#faf8ef',
                    boardBackground: '#bbada0',
                    textColor: '#776e65',
                    buttonBackground: '#8f7a66',
                    emptyCellColor: '#cdc1b4',

                    // Other settings
                    connectionLineThickness: 14,
                    borderRadius: 6,
                    hoverScale: 1.05,

                    // Mobile specific
                    mobileCellSize: 60,
                    mobileGridGap: 5,
                    mobilePreviewCircleSize: 50,
                    mobileCellFontSize: 24,
                    mobileHeaderFontSize: 36,
                    mobilePreviewFontSize: 16,
                    mobileConnectionLineThickness: 12
                };

                this.currentSettings = { ...this.defaults };
                this.loadSettings();
            }

            loadSettings() {
                const savedSettings = localStorage.getItem('connectItSettings');
                if (savedSettings) {
                    try {
                        const parsed = JSON.parse(savedSettings);
                        this.currentSettings = { ...this.defaults, ...parsed };
                    } catch (e) {
                        console.warn('Failed to load settings, using defaults');
                    }
                }
            }

            saveSettings() {
                localStorage.setItem('connectItSettings', JSON.stringify(this.currentSettings));
            }

            updateSetting(key, value) {
                this.currentSettings[key] = value;
                this.saveSettings();
                this.applySettings();
            }

            resetToDefaults() {
                this.currentSettings = { ...this.defaults };
                this.saveSettings();
                this.applySettings();
            }

            applySettings() {
                const root = document.documentElement;

                // Apply CSS custom properties
                root.style.setProperty('--animation-duration', this.currentSettings.animationDuration + 'ms');
                root.style.setProperty('--preview-transition', this.currentSettings.previewTransition + 'ms');
                root.style.setProperty('--cell-size', this.currentSettings.cellSize + 'px');
                root.style.setProperty('--grid-gap', this.currentSettings.gridGap + 'px');
                root.style.setProperty('--preview-circle-size', this.currentSettings.previewCircleSize + 'px');
                root.style.setProperty('--cell-font-size', this.currentSettings.cellFontSize + 'px');
                root.style.setProperty('--header-font-size', this.currentSettings.headerFontSize + 'px');
                root.style.setProperty('--preview-font-size', this.currentSettings.previewFontSize + 'px');
                root.style.setProperty('--background-color', this.currentSettings.backgroundColor);
                root.style.setProperty('--board-background', this.currentSettings.boardBackground);
                root.style.setProperty('--text-color', this.currentSettings.textColor);
                root.style.setProperty('--button-background', this.currentSettings.buttonBackground);
                root.style.setProperty('--empty-cell-color', this.currentSettings.emptyCellColor);
                root.style.setProperty('--connection-line-thickness', this.currentSettings.connectionLineThickness + 'px');
                root.style.setProperty('--border-radius', this.currentSettings.borderRadius + 'px');
                root.style.setProperty('--hover-scale', this.currentSettings.hoverScale);

                // Mobile settings
                root.style.setProperty('--mobile-cell-size', this.currentSettings.mobileCellSize + 'px');
                root.style.setProperty('--mobile-grid-gap', this.currentSettings.mobileGridGap + 'px');
                root.style.setProperty('--mobile-preview-circle-size', this.currentSettings.mobilePreviewCircleSize + 'px');
                root.style.setProperty('--mobile-cell-font-size', this.currentSettings.mobileCellFontSize + 'px');
                root.style.setProperty('--mobile-header-font-size', this.currentSettings.mobileHeaderFontSize + 'px');
                root.style.setProperty('--mobile-preview-font-size', this.currentSettings.mobilePreviewFontSize + 'px');
                root.style.setProperty('--mobile-connection-line-thickness', this.currentSettings.mobileConnectionLineThickness + 'px');
            }

            getSettingsAsJSON() {
                return JSON.stringify(this.currentSettings, null, 2);
            }
        }

        class ConnectItGame {
            constructor() {
                this.board = [];
                this.size = 5;
                this.isConnecting = false;
                this.connectedCells = [];
                this.startCell = null;
                this.currentValue = 0;
                this.connectionLines = [];
                this.updatePending = false; // Flag to throttle updates

                this.initializeBoard();
                this.loadGame();
                this.render();
                this.setupEventListeners();
            }

            initializeBoard() {
                for (let i = 0; i < this.size; i++) {
                    this.board[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        this.board[i][j] = this.getRandomPowerOf2();
                    }
                }
                this.ensurePlayable();
            }

            getRandomPowerOf2() {
                const powers = [2, 4, 8, 16, 32];
                return powers[Math.floor(Math.random() * powers.length)];
            }

            ensurePlayable() {
                let hasAdjacent = false;

                // Check if there are any adjacent pairs
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const neighbors = this.getNeighbors(i, j);
                        for (const [ni, nj] of neighbors) {
                            if (this.board[i][j] === this.board[ni][nj]) {
                                hasAdjacent = true;
                                break;
                            }
                        }
                        if (hasAdjacent) break;
                    }
                    if (hasAdjacent) break;
                }

                // If no adjacent pairs, create some
                if (!hasAdjacent) {
                    let changes = 0;
                    while (changes < 3 && !this.hasAdjacentPairs()) {
                        const i = Math.floor(Math.random() * this.size);
                        const j = Math.floor(Math.random() * this.size);
                        const neighbors = this.getNeighbors(i, j);

                        if (neighbors.length > 0) {
                            const [ni, nj] = neighbors[Math.floor(Math.random() * neighbors.length)];
                            this.board[i][j] = this.board[ni][nj];
                            changes++;
                        }
                    }
                }
            }

            hasAdjacentPairs() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const neighbors = this.getNeighbors(i, j);
                        for (const [ni, nj] of neighbors) {
                            if (this.board[i][j] === this.board[ni][nj]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            getNeighbors(row, col) {
                const neighbors = [];
                for (let di = -1; di <= 1; di++) {
                    for (let dj = -1; dj <= 1; dj++) {
                        if (di === 0 && dj === 0) continue;
                        const ni = row + di;
                        const nj = col + dj;
                        if (ni >= 0 && ni < this.size && nj >= 0 && nj < this.size) {
                            neighbors.push([ni, nj]);
                        }
                    }
                }
                return neighbors;
            }

            formatNumber(value) {
                if (value < 1024) {
                    return value.toString();
                } else if (value < 1048576) {
                    return (value / 1024) + 'K';
                } else {
                    return (value / 1048576) + 'M';
                }
            }

            needsRim(value) {
                return value >= 1024 && value < 1048576;
            }

            getBiggestPowerOf2(sum) {
                if (sum <= 1) return 1;
                let power = 1;
                while (power * 2 <= sum) {
                    power *= 2;
                }
                return power;
            }

            render() {
                const gameBoard = document.getElementById('gameBoard');
                gameBoard.innerHTML = '';

                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.value = this.board[i][j];
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.textContent = this.formatNumber(this.board[i][j]);
                        cell.style.transform = ''; // Reset any previous transforms

                        if (this.needsRim(this.board[i][j])) {
                            cell.classList.add('rim');
                        }

                        gameBoard.appendChild(cell);
                    }
                }
            }

            setupEventListeners() {
                const gameBoard = document.getElementById('gameBoard');

                // Mouse events
                gameBoard.addEventListener('mousedown', this.handleStart.bind(this));
                gameBoard.addEventListener('mousemove', this.handleMove.bind(this));
                gameBoard.addEventListener('mouseup', this.handleEnd.bind(this));
                gameBoard.addEventListener('mouseleave', this.handleEnd.bind(this));

                // Touch events
                gameBoard.addEventListener('touchstart', this.handleStart.bind(this));
                gameBoard.addEventListener('touchmove', this.handleMove.bind(this));
                gameBoard.addEventListener('touchend', this.handleEnd.bind(this));
            }

            handleStart(event) {
                event.preventDefault();
                const cell = event.target.closest('.cell');
                if (!cell) return;

                this.isConnecting = true;
                this.startCell = {
                    row: parseInt(cell.dataset.row),
                    col: parseInt(cell.dataset.col)
                };
                this.currentValue = this.board[this.startCell.row][this.startCell.col];
                this.connectedCells = [this.startCell];
                this.updateConnectedCells();
                this.updatePreview();
            }

            handleMove(event) {
                if (!this.isConnecting) return;
                event.preventDefault();

                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                const clientY = event.clientY || (event.touches && event.touches[0].clientY);

                const element = document.elementFromPoint(clientX, clientY);
                const cell = element && element.closest('.cell');

                if (!cell) return;

                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                if (this.board[row][col] !== this.currentValue) return;

                // Check if this cell is already in the path
                const cellIndex = this.connectedCells.findIndex(c => c.row === row && c.col === col);

                let needsUpdate = false;

                if (cellIndex !== -1) {
                    // Backtrack: remove all cells after this one
                    const newLength = cellIndex + 1;
                    if (this.connectedCells.length !== newLength) {
                        this.connectedCells = this.connectedCells.slice(0, newLength);
                        needsUpdate = true;
                    }
                } else {
                    // Check if adjacent to last cell
                    const lastCell = this.connectedCells[this.connectedCells.length - 1];
                    const neighbors = this.getNeighbors(lastCell.row, lastCell.col);
                    const isAdjacent = neighbors.some(([nr, nc]) => nr === row && nc === col);

                    if (isAdjacent) {
                        this.connectedCells.push({ row, col });
                        needsUpdate = true;
                    }
                }

                // Throttle updates using requestAnimationFrame
                if (needsUpdate && !this.updatePending) {
                    this.updatePending = true;
                    requestAnimationFrame(() => {
                        this.updateConnectedCells();
                        this.updatePreview();
                        this.updatePending = false;
                    });
                }
            }

            handleEnd(event) {
                if (!this.isConnecting) return;
                event.preventDefault();

                this.isConnecting = false;

                if (this.connectedCells.length > 1) {
                    this.collapseConnectedCells();
                } else {
                    // If no cells were collapsed, we still need to clean up
                    this.clearConnections();
                    this.hidePreview();
                }
            }

            updateConnectedCells() {
                // Update connected class on all cells (remove from all, then add to connected)
                document.querySelectorAll('.cell.connected').forEach(cell => {
                    cell.classList.remove('connected');
                });

                this.connectedCells.forEach(cell => {
                    const cellElement = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                    if (cellElement) {
                        cellElement.classList.add('connected');
                    }
                });

                // Update connection lines efficiently
                this.updateConnectionLines();
            }

            updateConnectionLines() {
                const requiredLines = this.connectedCells.length - 1;

                // Remove excess lines if we have too many
                while (this.connectionLines.length > requiredLines) {
                    const line = this.connectionLines.pop();
                    line.remove();
                }

                // Update existing lines and add new ones as needed
                for (let i = 0; i < requiredLines; i++) {
                    if (i < this.connectionLines.length) {
                        // Update existing line
                        this.updateConnectionLine(this.connectionLines[i], this.connectedCells[i], this.connectedCells[i + 1]);
                    } else {
                        // Create new line
                        const line = this.createConnectionLine(this.connectedCells[i], this.connectedCells[i + 1]);
                        this.connectionLines.push(line);
                    }
                }
            }

            createConnectionLine(cell1, cell2) {
                const gameBoard = document.getElementById('gameBoard');
                const line = document.createElement('div');
                line.className = 'connection-line';
                gameBoard.appendChild(line);

                // Set up the line immediately without animation for smoother experience
                this.updateConnectionLine(line, cell1, cell2);

                return line;
            }

            updateConnectionLine(lineElement, cell1, cell2) {
                const gameBoard = document.getElementById('gameBoard');
                const cell1Element = document.querySelector(`[data-row="${cell1.row}"][data-col="${cell1.col}"]`);
                const cell2Element = document.querySelector(`[data-row="${cell2.row}"][data-col="${cell2.col}"]`);

                if (!cell1Element || !cell2Element) return;

                const rect1 = cell1Element.getBoundingClientRect();
                const rect2 = cell2Element.getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();

                const x1 = rect1.left + rect1.width / 2 - boardRect.left;
                const y1 = rect1.top + rect1.height / 2 - boardRect.top;
                const x2 = rect2.left + rect2.width / 2 - boardRect.left;
                const y2 = rect2.top + rect2.height / 2 - boardRect.top;

                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1);

                // Get the actual line height from computed styles
                const lineHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--line-height') ||
                    (window.innerWidth <= 600 ? '12' : '14'));

                lineElement.style.left = x1 + 'px';
                lineElement.style.top = (y1 - lineHeight / 2) + 'px';
                lineElement.style.width = length + 'px';
                lineElement.style.transform = `rotate(${angle}rad)`;
                lineElement.style.color = window.getComputedStyle(cell1Element).backgroundColor;
            }


            clearConnections() {
                // Remove connected class from all cells
                document.querySelectorAll('.cell.connected').forEach(cell => {
                    cell.classList.remove('connected');
                });

                // Remove connection lines
                this.connectionLines.forEach(line => line.remove());
                this.connectionLines = [];
            }

            updatePreview() {
                const previewCircle = document.getElementById('previewCircle');

                if (this.connectedCells.length <= 1) {
                    previewCircle.classList.remove('visible');
                    return;
                }

                const sum = this.connectedCells.length * this.currentValue;
                const resultValue = this.getBiggestPowerOf2(sum);

                previewCircle.textContent = this.formatNumber(resultValue);
                previewCircle.dataset.value = resultValue;
                previewCircle.classList.toggle('rim', this.needsRim(resultValue));
                previewCircle.classList.add('visible');
            }

            hidePreview() {
                const previewCircle = document.getElementById('previewCircle');
                previewCircle.classList.remove('visible');
            }

            collapseConnectedCells() {
                if (this.connectedCells.length <= 1) return;

                const sum = this.connectedCells.length * this.currentValue;
                const resultValue = this.getBiggestPowerOf2(sum);
                const lastCell = this.connectedCells[this.connectedCells.length - 1];

                // Start animation sequence
                this.animateCollapse(resultValue, lastCell);
            }

            async animateCollapse(resultValue, lastCell) {
                // Phase 0: Clear connections before starting collapse animation
                this.clearConnections();
                this.hidePreview();

                // Phase 1: Move cells along connection lines to the target cell
                await this.animateMovingCells(lastCell);

                // Phase 2: Update board data
                this.updateBoardAfterCollapse(resultValue, lastCell);

                // Phase 3: Apply gravity with animation
                await this.animateGravity();

                // Phase 4: Fill empty cells with animation
                await this.animateFillEmptyCells();

                // Phase 5: Save the game
                this.saveGame();
            }

            animateMovingCells(targetCell) {
                return new Promise(resolve => {
                    const targetElement = document.querySelector(`[data-row="${targetCell.row}"][data-col="${targetCell.col}"]`);
                    const targetRect = targetElement.getBoundingClientRect();
                    const gameBoard = document.getElementById('gameBoard');
                    const boardRect = gameBoard.getBoundingClientRect();

                    // Move all cells except the target to the target position
                    const movingCells = this.connectedCells.slice(0, -1);
                    movingCells.forEach(cell => {
                        const cellElement = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                        const cellRect = cellElement.getBoundingClientRect();

                        const deltaX = targetRect.left - cellRect.left;
                        const deltaY = targetRect.top - cellRect.top;

                        cellElement.classList.add('moving');
                        cellElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(0)`;
                    });

                    // Wait for animation to complete
                    setTimeout(resolve, settings.currentSettings.animationDuration);
                });
            }

            updateBoardAfterCollapse(resultValue, lastCell) {
                // Set the last cell to the result value
                this.board[lastCell.row][lastCell.col] = resultValue;

                // Mark other cells as empty
                for (let i = 0; i < this.connectedCells.length - 1; i++) {
                    const cell = this.connectedCells[i];
                    this.board[cell.row][cell.col] = 0;
                }

                // Update the target cell immediately
                const targetElement = document.querySelector(`[data-row="${lastCell.row}"][data-col="${lastCell.col}"]`);
                targetElement.dataset.value = resultValue;
                targetElement.textContent = this.formatNumber(resultValue);
                targetElement.className = 'cell';
                if (this.needsRim(resultValue)) {
                    targetElement.classList.add('rim');
                }
            }

            animateGravity() {
                return new Promise(resolve => {
                    // First, calculate what the board should look like after gravity
                    const newBoard = [];
                    for (let i = 0; i < this.size; i++) {
                        newBoard[i] = [];
                        for (let j = 0; j < this.size; j++) {
                            newBoard[i][j] = 0;
                        }
                    }

                    // Apply gravity logic to get final positions
                    for (let j = 0; j < this.size; j++) {
                        const values = [];
                        for (let i = this.size - 1; i >= 0; i--) {
                            if (this.board[i][j] !== 0) {
                                values.push(this.board[i][j]);
                            }
                        }
                        for (let i = this.size - 1; i >= 0; i--) {
                            if (values.length > 0) {
                                newBoard[i][j] = values.shift();
                            }
                        }
                    }

                    // Animate cells that need to move
                    const movements = [];
                    for (let j = 0; j < this.size; j++) {
                        const originalValues = [];
                        const finalValues = [];

                        // Get original non-zero values and their positions
                        for (let i = 0; i < this.size; i++) {
                            if (this.board[i][j] !== 0) {
                                originalValues.push({ row: i, value: this.board[i][j] });
                            }
                        }

                        // Get final positions of non-zero values
                        for (let i = 0; i < this.size; i++) {
                            if (newBoard[i][j] !== 0) {
                                finalValues.push({ row: i, value: newBoard[i][j] });
                            }
                        }

                        // Match original positions to final positions
                        for (let k = 0; k < originalValues.length; k++) {
                            const originalCell = originalValues[k];
                            const finalCell = finalValues[k];

                            if (originalCell.row !== finalCell.row) {
                                movements.push({
                                    fromRow: originalCell.row,
                                    toRow: finalCell.row,
                                    col: j,
                                    value: originalCell.value
                                });
                            }
                        }
                    }

                    // Apply visual animations
                    movements.forEach(movement => {
                        const cellElement = document.querySelector(`[data-row="${movement.fromRow}"][data-col="${movement.col}"]`);
                        if (cellElement) {
                            const cellHeight = cellElement.offsetHeight;
                            const gap = 10; // grid gap
                            const deltaY = (movement.toRow - movement.fromRow) * (cellHeight + gap);

                            cellElement.classList.add('falling');
                            cellElement.style.transform = `translateY(${deltaY}px)`;
                        }
                    });

                    // Update the board state
                    this.board = newBoard;

                    // Wait for animation to complete
                    setTimeout(resolve, settings.currentSettings.animationDuration);
                });
            }

            animateFillEmptyCells() {
                return new Promise(resolve => {
                    const emptyCells = [];
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            if (this.board[i][j] === 0) {
                                emptyCells.push([i, j]);
                            }
                        }
                    }

                    // Generate new values
                    const newValues = [];
                    emptyCells.forEach(([i, j]) => {
                        const value = this.getRandomPowerOf2();
                        this.board[i][j] = value;
                        newValues.push({ row: i, col: j, value });
                    });

                    // Check if board is still playable
                    if (!this.hasAdjacentPairs() && emptyCells.length > 0) {
                        const randomNewCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        const [i, j] = randomNewCell;
                        const neighbors = this.getNeighbors(i, j);
                        if (neighbors.length > 0) {
                            const [ni, nj] = neighbors[Math.floor(Math.random() * neighbors.length)];
                            this.board[i][j] = this.board[ni][nj];
                            // Update the corresponding newValue
                            const newValueEntry = newValues.find(nv => nv.row === i && nv.col === j);
                            if (newValueEntry) {
                                newValueEntry.value = this.board[i][j];
                            }
                        }
                    }

                    // Re-render entire board
                    this.render();

                    // Add animation class to new cells
                    newValues.forEach(({ row, col }) => {
                        const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        if (cellElement) {
                            cellElement.classList.add('new-cell');
                            // Remove animation class after animation completes
                            setTimeout(() => {
                                cellElement.classList.remove('new-cell');
                            }, settings.currentSettings.animationDuration);
                        }
                    });

                    setTimeout(resolve, settings.currentSettings.animationDuration);
                });
            }


            saveGame() {
                localStorage.setItem('connectItGame', JSON.stringify(this.board));
            }

            loadGame() {
                const savedGame = localStorage.getItem('connectItGame');
                if (savedGame) {
                    try {
                        this.board = JSON.parse(savedGame);
                        // Validate the loaded board
                        if (!Array.isArray(this.board) || this.board.length !== this.size) {
                            throw new Error('Invalid board size');
                        }
                        for (let i = 0; i < this.size; i++) {
                            if (!Array.isArray(this.board[i]) || this.board[i].length !== this.size) {
                                throw new Error('Invalid board structure');
                            }
                        }
                    } catch (e) {
                        // If loading fails, initialize new board
                        this.initializeBoard();
                    }
                }
            }

            reset() {
                this.initializeBoard();
                this.render();
                this.saveGame();
            }
        }

        let game;
        let settings;

        function initGame() {
            settings = new SettingsManager();
            settings.applySettings();
            game = new ConnectItGame();
        }

        function resetGame() {
            game.reset();
        }

        // Settings modal functions
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            const form = document.getElementById('settingsForm');

            // Populate form with current settings
            populateSettingsForm();

            modal.style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function populateSettingsForm() {
            const form = document.getElementById('settingsForm');
            const currentSettings = settings.currentSettings;

            // Get all form inputs and populate them with current values
            const inputs = form.querySelectorAll('input');
            inputs.forEach(input => {
                const settingName = input.name;
                if (settingName && currentSettings.hasOwnProperty(settingName)) {
                    let value = currentSettings[settingName];
                    if (input.type === 'color' && !value.startsWith('#')) {
                        // Convert color names or rgb values to hex if needed
                        value = rgbToHex(value) || value;
                    }
                    input.value = value;
                }
            });
        }

        function applySettings() {
            const form = document.getElementById('settingsForm');
            const formData = new FormData(form);

            // Update settings from form
            for (let [key, value] of formData.entries()) {
                if (key in settings.currentSettings) {
                    // Convert string values to appropriate types
                    if (typeof settings.currentSettings[key] === 'number') {
                        value = parseFloat(value);
                    }
                    settings.updateSetting(key, value);
                }
            }

            closeSettings();
        }

        function resetToDefaults() {
            settings.resetToDefaults();
            populateSettingsForm();
        }

        function copyAsJSON() {
            document.getElementById('settingsModal').style.display = 'none';
            document.getElementById('jsonModal').style.display = 'block';
            document.getElementById('jsonDisplay').value = settings.getSettingsAsJSON();
        }

        function closeJSON() {
            document.getElementById('jsonModal').style.display = 'none';
        }

        function copyJSONToClipboard() {
            const textarea = document.getElementById('jsonDisplay');
            textarea.select();
            document.execCommand('copy');

            // Show a brief confirmation (could enhance this with a toast message)
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 1000);
        }

        // Helper function to convert rgb color to hex
        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb;

            const result = rgb.match(/\d+/g);
            if (!result || result.length < 3) return rgb;

            return '#' + result.slice(0, 3).map(x => {
                const hex = parseInt(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // Close modals when clicking outside of them
        window.addEventListener('click', function(event) {
            const settingsModal = document.getElementById('settingsModal');
            const jsonModal = document.getElementById('jsonModal');

            if (event.target === settingsModal) {
                closeSettings();
            }
            if (event.target === jsonModal) {
                closeJSON();
            }
        });

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>